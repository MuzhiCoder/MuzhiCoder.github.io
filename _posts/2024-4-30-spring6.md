---
layout: post
title: Spring6
description: Spring6基础知识文档
date: 2024-4-30 08:34:20 +0800
author: MuZhi
categories: [框架,Spring]
tags: [Spring,框架]
pin: false
toc: true
math: true 
mermaid: true 
image:
  path: public-images/spring-ioc.png
  lqip: data:image/webp;base64,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
  alt: Spring6 基础
---

## 1、概述

### 1.1、Spring是什么？

Spring 是一款主流的 Java EE 轻量级开源框架 ，Spring 由“Spring 之父”Rod Johnson 提出并创立，其目的是用于简化 Java 企业级应用的开发难度和开发周期。Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring 框架除了自己提供功能外，还提供整合其他技术和框架的能力。

Spring 自诞生以来备受青睐，一直被广大开发人员作为 Java 企业级应用程序开发的首选。时至今日，Spring 俨然成为了 Java EE 代名词，成为了构建 Java EE 应用的事实标准。

自 2004 年 4 月，Spring 1.0 版本正式发布以来，Spring 已经步入到了第 6 个大版本，也就是 Spring 6。本课程采用Spring当前最新发布的正式版本**6.0.2**。

![image-20221216223135162](https://raw.githubusercontent.com/MuzhiCoder/MuZhiCoderImages/main/public-images/image-spring-framework.png)


### 1.2、Spring 的狭义和广义

在不同的语境中，Spring 所代表的含义是不同的。下面我们就分别从“广义”和“狭义”两个角度，对 Spring 进行介绍。

**广义的 Spring：Spring 技术栈**

广义上的 Spring 泛指以 Spring Framework 为核心的 Spring 技术栈。

经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。

这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。

**狭义的 Spring：Spring Framework**

狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。

Spring 框架是一个分层的、面向切面的 Java 应用程序的一站式轻量级解决方案，它是 Spring 技术栈的核心和基础，是为了解决企业级应用开发的复杂性而创建的。

Spring 有两个最核心模块： IoC 和 AOP。

**IoC**：Inverse of Control 的简写，译为“控制反转”，指把创建对象过程交给 Spring 进行管理。

**AOP**：Aspect Oriented Programming 的简写，译为“面向切面编程”。AOP 用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP 还解决一些系统层面上的问题，比如日志、事务、权限等。



### 1.3、Spring Framework特点

- 非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。

- 控制反转：IoC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。

- 面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。

- 容器：Spring IoC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。

- 组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。

- 一站式：在 IoC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且 Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。

  

### 1.4、Spring模块组成

官网地址：[https://spring.io/](https://spring.io/)

![image-20221207142746771](https://raw.githubusercontent.com/MuzhiCoder/MuZhiCoderImages/main/public-images/image-spring-core.png)

![image-2097896352](https://raw.githubusercontent.com/MuzhiCoder/MuZhiCoderImages/main/public-images/image-spring-uml.png)

上图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍。

**Spring Core（核心容器）**

spring core提供了IOC,DI,Bean配置装载创建的核心实现。核心概念： Beans、BeanFactory、BeanDefinitions、ApplicationContext。

- spring-core ：IOC和DI的基本实现

- spring-beans：BeanFactory和Bean的装配管理(BeanFactory)
- spring-context：Spring context上下文，即IOC容器(AppliactionContext)
- spring-expression：spring表达式语言

**Spring AOP**

- spring-aop：面向切面编程的应用模块，整合ASM，CGLib，JDK Proxy
- spring-aspects：集成AspectJ，AOP应用框架
- spring-instrument：动态Class Loading模块

**Spring Data Access**

- spring-jdbc：spring对JDBC的封装，用于简化jdbc操作
- spring-orm：java对象与数据库数据的映射框架
- spring-oxm：对象与xml文件的映射框架
- spring-jms： Spring对Java Message Service(java消息服务)的封装，用于服务之间相互通信
- spring-tx：spring jdbc事务管理

**Spring Web**

- spring-web：最基础的web支持，建立于spring-context之上，通过servlet或listener来初始化IOC容器
- spring-webmvc：实现web mvc
- spring-websocket：与前端的全双工通信协议
- spring-webflux：Spring 5.0提供的，用于取代传统java servlet，非阻塞式Reactive Web框架，异步，非阻塞，事件驱动的服务

**Spring Message**

- Spring-messaging：spring 4.0提供的，为Spring集成一些基础的报文传送服务

**Spring test**

- spring-test：集成测试支持，主要是对junit的封装

  

### 1.5、Spring6特点

#### 1.5.1、版本要求

**（1）Spring6要求JDK最低版本是JDK17**

![image-20221201103138194](https://raw.githubusercontent.com/MuzhiCoder/MuZhiCoderImages/main/public-images/image-spring-jdk.png)



## 2、入门

### 2.1、运行环境

- JDK：Java17 +  **Spring6 要求JDK最低版本是Java17**
- Maven：3.6.x
- Spring：6.0.2



### 2.2、构建模块

1. 构建父模块 Spring6

> 在IDEA中，依次单击 新建 - > 项目 - > 新建项目 - > 创建

![image-20240501221012329](https://raw.githubusercontent.com/MuzhiCoder/MuZhiCoderImages/main/public-images/image-spring-new.png)

2. 构建子模块 `spring6-first`



### 2.3、入门案例

#### 2.3.1、引入依赖

> 官方文档：https://spring.io/projects/spring-framework#learn

添加依赖：

```xml
<dependencies>
    <!--spring context依赖-->
    <!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>6.0.2</version>
    </dependency>

    <!--junit5测试-->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-api</artifactId>
        <version>5.3.1</version>
    </dependency>
</dependencies>
```

![image-20240501222555291](https://raw.githubusercontent.com/MuzhiCoder/MuZhiCoderImages/main/public-images/image-spring-yl.png)



#### 2.3.2、创建Java类

```java
package com.muzhi.spring6.bean;

public class HelloWorld {

    public static void main(String[] args) {
        System.out.println("Hello World");
    }
}

```



#### 2.3.3、创建配置文件

> 在resources目录创建一个 Spring 配置文件 beans.xml（配置文件名称可随意命名，如：springs-bean.xm）

![image-20240501223129343](https://raw.githubusercontent.com/MuzhiCoder/MuZhiCoderImages/main/public-images/image-spring-bean.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--
    配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理
    通过bean标签配置IOC容器所管理的bean
    属性：
        id：设置bean的唯一标识
        class：设置bean所对应类型的全类名
	-->
    <bean id="helloWorld" class="com.muzhi.spring6.bean.HelloWorld"></bean>
</beans>
```



#### 2.3.4、创建测试类

```java
package com.muzhi.test;

import com.muzhi.spring6.bean.HelloWorld;
import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class HelloWorldTest {

    @Test
    public void testHelloWorld() {
        // 加载Spring 配置文件
        ApplicationContext ac = new ClassPathXmlApplicationContext("spring-bean.xml");
        // 获取Bean对象
        HelloWorld helloWorld = (HelloWorld) ac.getBean("helloWorld");
        // 调用Bean的方法
        helloWorld.sayHello();
    }
}
```



#### 2.4、案例分析

1. 底层创建对象是通过反射机制调用无参构造方法。

修改HelloWorld 类：

```java
public class HelloWorld {

    public HelloWorld() {
        System.out.println("HelloWorld 无参构造方法");
    }

    public void sayHello(){
        System.out.println("Hello World");
    }
}
```

执行结果：

![image-20240501224637452](https://raw.githubusercontent.com/MuzhiCoder/MuZhiCoderImages/main/public-images/image-helloworldrun.png)

测试可知：创建对象时调用了无参构造方法。

2. Spring如何创建的对象，原理是什么?

   1. 加载bean.xml配置文件
   2. 对xml文件进行解析操作。
   3. 获取xml文件bean标签属性值 `id属性值`、`class属性值`
   4. 使用反射根据`class属性值` 全路径创建对象。

   ```java
       @Test
       public void testHelloWorld2() throws Exception {
           // 反射创建对象
           Class aClass = Class.forName("com.muzhi.spring6.bean.HelloWorld");
           // 获取对象
           HelloWorld helloWorld = (HelloWorld) aClass.newInstance();
           helloWorld.sayHello();
           // 或者
           HelloWorld helloWorld2 = (HelloWorld) aClass.getDeclaredConstructor().newInstance();
           helloWorld2.sayHello();
       }
   ```

3. 创建后的对象存储在哪里。

> bean对象最终存储在spring容器中，在spring源码底层就是一个map集合，存储bean的map在**DefaultListableBeanFactory**类中：

```java
private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);
key：唯一标识
value：类的定义 (描述信息：BeanDefinition)    
```

> Spring容器加载到Bean类时 , 会把这个类的描述信息, 以包名加类名的方式存到beanDefinitionMap 中Map<String,BeanDefinition> , 其中 String是Key , 默认是类名首字母小写 , BeanDefinition , 存的是类的定义(描述信息) , 我们通常叫BeanDefinition接口为 : bean的定义对象。



### 2.5、启用Log4j2日志框架

#### 2.5.1、Log4j2日志概述

在项目开发中，日志十分的重要，不管是记录运行情况还是定位线上问题，都离不开对日志的分析。日志记录了系统行为的时间、地点、状态等相关信息，能够帮助我们了解并监控系统状态，在发生错误或者接近某种危险状态时能够及时提醒我们处理，同时在系统产生问题时，能够帮助我们快速的定位、诊断并解决问题。

**Apache Log4j2**是一个开源的日志记录组件，使用非常的广泛。在工程中以易用方便代替了 System.out 等打印语句，它是JAVA下最流行的日志输入工具。 

**Log4j2主要由几个重要的组件构成：**

**（1）日志信息的优先级**，日志信息的优先级从高到低有**TRACE < DEBUG < INFO < WARN < ERROR < FATAL**
                TRACE：追踪，是最低的日志级别，相当于追踪程序的执行
                DEBUG：调试，一般在开发中，都将其设置为最低的日志级别
                INFO：信息，输出重要的信息，使用较多
                WARN：警告，输出警告的信息
                ERROR：错误，输出错误信息
                FATAL：严重错误

这些级别分别用来指定这条日志信息的重要程度；级别高的会自动屏蔽级别低的日志，也就是说，设置了WARN的日志，则INFO、DEBUG的日志级别的日志不会显示

**（2）日志信息的输出目的地**，日志信息的输出目的地指定了日志将打印到**控制台**还是**文件中**；

**（3）日志信息的输出格式**，而输出格式则控制了日志信息的显示内容。



#### 2.5.2、引入Log4j2依赖

```xml
<!--log4j2的依赖-->
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.19.0</version>
</dependency>
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-slf4j2-impl</artifactId>
    <version>2.19.0</version>
</dependency>
```



#### 2.5.3、加入日志配置文件

在类的根路径下提供log4j2.xml配置文件（文件名固定为：log4j2.xml，文件必须放到类根路径下。）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <loggers>
        <!--
            level指定日志级别，从低到高的优先级：
                TRACE < DEBUG < INFO < WARN < ERROR < FATAL
                trace：追踪，是最低的日志级别，相当于追踪程序的执行
                debug：调试，一般在开发中，都将其设置为最低的日志级别
                info：信息，输出重要的信息，使用较多
                warn：警告，输出警告的信息
                error：错误，输出错误信息
                fatal：严重错误
        -->
        <root level="DEBUG">
            <appender-ref ref="spring6log"/>
            <appender-ref ref="RollingFile"/>
            <appender-ref ref="log"/>
        </root>
    </loggers>

    <appenders>
        <!--输出日志信息到控制台-->
        <console name="spring6log" target="SYSTEM_OUT">
            <!--控制日志输出的格式-->
            <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss SSS} [%t] %-3level %logger{1024} - %msg%n"/>
        </console>

        <!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用-->
        <File name="log" fileName="d:/spring6_log/test.log" append="false">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n"/>
        </File>

        <!-- 这个会打印出所有的信息，
            每次大小超过size，
            则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，
            作为存档-->
        <RollingFile name="RollingFile" fileName="d:/spring6_log/app.log"
                     filePattern="log/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz">
            <PatternLayout pattern="%d{yyyy-MM-dd 'at' HH:mm:ss z} %-5level %class{36} %L %M - %msg%xEx%n"/>
            <SizeBasedTriggeringPolicy size="50MB"/>
            <!-- DefaultRolloverStrategy属性如不设置，
            则默认为最多同一文件夹下7个文件，这里设置了20 -->
            <DefaultRolloverStrategy max="20"/>
        </RollingFile>
    </appenders>
</configuration>
```



#### 2.5.4、使用日志

```java
private static final Log log = LogFactory.getLog(HelloWorldTest.class);

log.info("testHelloWorld");
```

![image-20240501231742594](https://raw.githubusercontent.com/MuzhiCoder/MuZhiCoderImages/main/public-images/image-log.png)



## 3、容器

IOC，即“控制反转”（Inversion of Control），是一种设计原则，用于减少计算机编程中的耦合度。在传统的程序设计中，组件之间的依赖关系通常是由组件自身在内部创建和维护的。而在IoC容器中，这种创建和管理依赖关系的责任被转移到了外部容器，组件之间的依赖关系由容器在运行时动态注入。

### 3.1、IOC容器

#### 3.1.1、控制反转 IOC

控制反转是一种设计原则，它的核心思想是将传统上由程序代码所控制的某些方面转交给框架或容器来处理。在软件工程中，IoC 可以应用在多个层面，比如：

- **对象创建**：不是由使用对象的代码来创建对象，而是由容器在运行时创建对象。
- **对象查找**：不是由对象自己查找依赖，而是由容器提供依赖对象。
- **对象生命周期管理**：不是由对象自己管理其生命周期，而是由容器负责创建、初始化、使用、销毁对象。

#### 3.1.2、依赖注入DI

依赖注入是实现控制反转的一种具体方式，它专注于组件之间的依赖关系管理。在依赖注入中，组件不负责创建或查找它的依赖，而是通过构造函数、方法参数、属性或工厂方法等方式，由容器将依赖对象“注入”到组件中。

依赖注入可以进一步细分为几种不同的注入方式：

1. **构造函数注入**：通过对象的构造函数传递依赖。
2. **设值注入**：通过**setter**方法或属性赋值来注入依赖。
3. **接口注入**：通过**接口**传递依赖对象。
4. **方法注入**：在组件的某个方法中，通过方法参数传递依赖。

#### 3.1.3、IOC容器在Spring中实现

![](https://raw.githubusercontent.com/MuzhiCoder/MuZhiCoderImages/main/public-images/IOC-Spring%E5%AE%9E%E7%8E%B0.png)

1. BeanFactory：是 IoC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用
2. ApplicationContext：BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。![BeanFactory](https://raw.githubusercontent.com/MuzhiCoder/MuZhiCoderImages/main/public-images/BeanFactory.png)

| 类型名                          | 简介                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| ClassPathXmlApplicationContext  | 通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象       |
| FileSystemXmlApplicationContext | 通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象     |
| ConfigurableApplicationContext  | ApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文的能力。 |
| WebApplicationContext           | 专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。 |

### 3.2、基于XML管理Bean

#### 3.2.1、搭建子模块spring6-ioc-xml

1. 创建方式参考：spring6-first
2. 引入配置文件：bean.xml、log4j2.xml
3. 添加依赖 
4. 引入Java类
```xml
!--log4j2的依赖-->
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-core</artifactId>
        <version>2.19.0</version>
    </dependency>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-slf4j2-impl</artifactId>
        <version>2.19.0</version>
    </dependency>
```

#### 3.2.2、获取Bean

##### 1、根据ID获取

由于 id 属性指定了 bean 的唯一标识，所以根据 bean 标签的 id 属性可以精确获取到一个组件对象。

```java
HelloWorld helloWorld = (HelloWorld) ac.getBean("helloWorld");
```

##### 2、根据类型获取

```java
    @Test
    public void testHelloWorld() {
        // 加载Spring 配置文件
        ApplicationContext ac = new ClassPathXmlApplicationContext("spring-bean.xml");
        // 获取Bean对象
        HelloWorld helloWorld = ac.getBean(HelloWorld.class);
        // 调用Bean的方法
        helloWorld.sayHello();
    }
```

##### 3、根据ID和类型

```java
	@Test
    public void testHelloWorld3() throws Exception {
        log.info("testHelloWorld3");
        // 加载Spring 配置文件
        ApplicationContext ac = new ClassPathXmlApplicationContext("spring-bean.xml");
        // 获取Bean对象
        HelloWorld helloWorld = ac.getBean("helloWorld", HelloWorld.class);
        // 调用Bean的方法
        helloWorld.sayHello();
    }
```

##### 4、注意

当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个

当IOC容器中一共配置了两个：

```xml
    <bean id="helloWorld" class="com.muzhi.spring6.bean.HelloWorld"></bean>
    <bean id="helloWorld2" class="com.muzhi.spring6.bean.HelloWorld"></bean>
```

根据类型获取时会抛出异常：

![image-20240502005157015](https://raw.githubusercontent.com/MuzhiCoder/MuZhiCoderImages/main/public-images/image-20240502005157015.png)

##### 扩展

- 如果组件类实现了接口，根据接口类型可以获取 bean，但Bean必须是唯一的。
- 如果一个接口有多个实现类，这些实现类都配置了 bean，不能根据接口类型获取 bean，因为Bean不是唯一的。

根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 **instanceof** 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。

java中，instanceof运算符用于判断前面的对象是否是后面的类，或其子类、实现类的实例。如果是返回true，否则返回false。也就是说：用instanceof关键字做判断时， instanceof 操作符的左右操作必须有继承或实现关系

#### 3.2.3、依赖注入之setter注入

- 创建用户类User

```java
public class User {
    private String id;
    private String name;
    private int age;
    private String sex;
    public User() {}
    public String getId() {
        return id;
    }
    public void setId(String id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public String getSex() {
        return sex;
    }
    public void setSex(String sex) {
        this.sex = sex;
    }
    @Override
    public String toString() {
        return "User{" +
                "id='" + id + '\'' +
                ", name='" + name + '\'' +
                ", age=" + age +
                ", sex='" + sex + '\'' +
                '}';
    }
}
```

- 配置Bean并赋值

```xml
    <bean id="user" class="com.muzhi.spring6.bean.User">
        <!--
        使用property标签为bean的属性赋值
        属性：
            name：设置属性名
            value：设置属性值
        -->
        <property name="id" value="1"/>
        <property name="name" value="张三"/>
        <property name="age" value="20"/>
        <property name="sex" value="男"/>
    </bean>
```

- 测试并输出

```java
    @Test
    public void testUser() {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring-bean.xml");
        User user = context.getBean("user", User.class);
        System.out.println(user.toString());
    }

DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'user'
User{id='1', name='张三', age=20, sex='男'}
```

#### 3.2.4、依赖注入之构造器注入

- 在User类中添加有参构造

```java
    public User(String id, String name, int age, String sex) {
        this.id = id;
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
```

- 配置Bean 

```xml
    <bean id="user" class="com.muzhi.spring6.bean.User">
        <!--
        使用constructor-arg标签为bean的构造器赋值
        属性：
            name：设置构造器参数名
            value：设置构造器参数值
        -->
        <constructor-arg name="id" value="1"/>
        <constructor-arg name="name" value="张三"/>
        <constructor-arg name="age" value="20"/>
        <constructor-arg name="sex" value="男"/>
    </bean>
```

> 注意：
>
> constructor-arg标签还有两个属性可以进一步描述构造器参数：
>
> - index属性：指定参数所在位置的索引（从0开始）
> - name属性：指定参数名

- 测试 

```java
    @Test
    public void testUser() {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring-bean.xml");
        User user = context.getBean("user", User.class);
        System.out.println(user.toString());
    }

DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'user'
User{id='1', name='张三', age=20, sex='男'}
```

#### 3.2.5、特殊值处理

- 字面量赋值

```xml
<!-- 使用value属性给bean的属性赋值时，Spring会把value属性的值看做字面量 -->
<property name="name" value="张三"/>
```

- null值

``` xml
<property name="name">
    <null />
</property>
注意：
<property name="name" value="null"></property> 赋值为字符串 null 非 null
```

- xml实体

```xml
<!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 -->
<!-- 解决方案一：使用XML实体来代替 -->
<property name="expression" value="a &lt; b"/>
```

- CDATA 节

```xml
<property name="expression">
    <!-- 解决方案二：使用CDATA节 -->
    <!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 -->
    <!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 -->
    <!-- 所以CDATA节中写什么符号都随意 -->
    <value><![CDATA[a < b]]></value>
</property>
```

#### 3.2.6、为对象类型属性赋值

- 创建用户身份类：UserIdentity

```java
public class UserIdentity {
    private String name;
    private String idCard;

    public UserIdentity() {
    }

    public UserIdentity(String name, String idCard) {
        this.name = name;
        this.idCard = idCard;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getIdCard() {
        return idCard;
    }

    public void setIdCard(String idCard) {
        this.idCard = idCard;
    }

    @Override
    public String toString() {
        return "UserIdentity{" +
                "name='" + name + '\'' +
                ", idCard='" + idCard + '\'' +
                '}';
    }
}
```

- 修改User 类

```java
	private UserIdentity userIdentity;

    public UserIdentity getUserIdentity() {
        return userIdentity;
    }

    public void setUserIdentity(UserIdentity userIdentity) {
        this.userIdentity = userIdentity;
    }
```

##### 3.2.6.1、引用外部Bean

```xml
    <bean id="userIdentity" class="com.muzhi.spring6.bean.UserIdentity">
        <property name="name" value="身份证"/>
        <property name="idCard" value="123456789012345678"/>
    </bean>
	
	<property name="userIdentity" ref="userIdentity"/>
```

##### 3.2.6.2、内部Bean

```xml
	<property name="userIdentity">
		<bean id="userIdentity" class="com.muzhi.spring6.bean.UserIdentity">
			<property name="name" value="身份证"/>
			<property name="idCard" value="123456789012345678"/>
		</bean>
	</property>
```

##### 3.2.6.3、级联属性赋值

```xml
	<property name="userIdentity" ref="userIdentity"/>
	<property name="userIdentity.name" value="身份证"/>
	<property name="userIdentity.idCard" value="123456789012345678"/>
```

#### 3.2.7、为数组类型属性赋值

- 在User类 添加数组属性。

```java
    private List<String> hobbies;

    public List<String> getHobbies() {
        return hobbies;
    }

    public void setHobbies(List<String> hobbies) {
        this.hobbies = hobbies;
    }
```

- 配置Bean

```xml
    <!-- 使用list标签配置集合属性 -->
	<property name="hobbies">
		<list>
			<value>篮球</value>
            <value>足球</value>
            <value>乒乓球</value>
        </list>
	</property>
```

> 若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可

```xml
<!--map集合类型的bean-->
<property name="userIdentityMap">
        <map>
            <entry>
                <key>
                    <value>10010</value>
                </key>
                <ref bean="userIdentity"></ref>
            </entry>
            <entry>
                <key>
                    <value>10086</value>
                </key>
                <ref bean="userIdentity"></ref>
            </entry>
        </map>
</property>
```

#### 3.2.8、为集合类型属性赋值

##### 3.2.8.1. List集合类型属性赋值

- 在Clazz类中添加以下代码：

```java
private List<Student> students;

public List<Student> getStudents() {
    return students;
}

public void setStudents(List<Student> students) {
    this.students = students;
}
```

- 引用集合类型的bean

```xml
<bean id="clazzTwo" class="com.atguigu.spring6.bean.Clazz">
    <property name="clazzId" value="4444"></property>
    <property name="clazzName" value="Javaee0222"></property>
    <property name="students">
        <list>
            <ref bean="studentOne"></ref>
            <ref bean="studentTwo"></ref>
            <ref bean="studentThree"></ref>
        </list>
    </property>
</bean>
```

##### 3.2.8.2、为Map集合类型属性赋值

- 创建教师类Teacher：

```java
package com.muzhi.spring6.bean;
public class Teacher {

    private Integer teacherId;

    private String teacherName;

    public Integer getTeacherId() {
        return teacherId;
    }

    public void setTeacherId(Integer teacherId) {
        this.teacherId = teacherId;
    }

    public String getTeacherName() {
        return teacherName;
    }

    public void setTeacherName(String teacherName) {
        this.teacherName = teacherName;
    }

    public Teacher(Integer teacherId, String teacherName) {
        this.teacherId = teacherId;
        this.teacherName = teacherName;
    }

    public Teacher() {

    }
    
    @Override
    public String toString() {
        return "Teacher{" +
                "teacherId=" + teacherId +
                ", teacherName='" + teacherName + '\'' +
                '}';
    }
}
```

- 在Student类中添加以下代码：

```java
private Map<String, Teacher> teacherMap;

public Map<String, Teacher> getTeacherMap() {
    return teacherMap;
}

public void setTeacherMap(Map<String, Teacher> teacherMap) {
    this.teacherMap = teacherMap;
}
```

- 配置Bean

```xml
<bean id="teacherOne" class="com.muzhi.spring6.bean.Teacher">
    <property name="teacherId" value="10010"></property>
    <property name="teacherName" value="大宝"></property>
</bean>

<bean id="teacherTwo" class="com.muzhi.spring6.bean.Teacher">
    <property name="teacherId" value="10086"></property>
    <property name="teacherName" value="二宝"></property>
</bean>

<bean id="studentFour" class="com.muzhi.spring6.bean.Student">
    <property name="id" value="1004"></property>
    <property name="name" value="赵六"></property>
    <property name="age" value="26"></property>
    <property name="sex" value="女"></property>
    <!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 -->
    <property name="clazz" ref="clazzOne"></property>
    <property name="hobbies">
        <array>
            <value>唱歌</value>
            <value>跳舞</value>
            <value>上天</value>
        </array>
    </property>
    <property name="teacherMap">
        <map>
            <entry>
                <key>
                    <value>10010</value>
                </key>
                <ref bean="teacherOne"></ref>
            </entry>
            <entry>
                <key>
                    <value>10086</value>
                </key>
                <ref bean="teacherTwo"></ref>
            </entry>
        </map>
    </property>
</bean>
```

> 使用util:list、util:map标签必须引入相应的命名空间
>
> ```xml
> <?xml version="1.0" encoding="UTF-8"?>
> <beans xmlns="http://www.springframework.org/schema/beans"
>     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>     xmlns:util="http://www.springframework.org/schema/util"
>     xsi:schemaLocation="http://www.springframework.org/schema/util
>     http://www.springframework.org/schema/util/spring-util.xsd
>     http://www.springframework.org/schema/beans
>     http://www.springframework.org/schema/beans/spring-beans.xsd">
> ```

#### 3.2.9、P 命名空间

> 引入 p 命名空间
>
> ```xml
> <?xml version="1.0" encoding="UTF-8"?>
> <beans xmlns="http://www.springframework.org/schema/beans"
>        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>        xmlns:util="http://www.springframework.org/schema/util"
>        xmlns:p="http://www.springframework.org/schema/p"
>        xsi:schemaLocation="http://www.springframework.org/schema/util
>        http://www.springframework.org/schema/util/spring-util.xsd
>        http://www.springframework.org/schema/beans
>        http://www.springframework.org/schema/beans/spring-beans.xsd">
> ```

引入p命名空间后，可以通过以下方式为bean的各个属性赋值

```xml
<bean id="studentSix" class="com.muzhi.spring6.bean.Student"
    p:id="1006" p:name="小明" p:clazz-ref="clazzOne" p:teacherMap-ref="teacherMap">
</bean>
```

#### 3.2.10、引入外部属性文件

1. 加入依赖

   ```xml
    <!-- MySQL驱动 -->
   <dependency>
       <groupId>mysql</groupId>
       <artifactId>mysql-connector-java</artifactId>
       <version>8.0.30</version>
   </dependency>
   
   <!-- 数据源 -->
   <dependency>
       <groupId>com.alibaba</groupId>
       <artifactId>druid</artifactId>
       <version>1.2.15</version>
   </dependency>
   ```

2. 创建外部属性文件

   ```properties
   jdbc.username=root
   jdbc.password=root
   jdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC
   jdbc.driver=com.mysql.cj.jdbc.Driver
   ```

3. 引入属性文件

   1. 引入`context`名称空间

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context
          http://www.springframework.org/schema/context/spring-context.xsd">
   
   </beans>
   ```

   2. 引入外部属性文件

   ```xml
   <!-- 引入外部属性文件 -->
   <context:property-placeholder location="classpath:jdbc.properties"/>
   ```

   注意：在使用 <context:property-placeholder> 元素加载外包配置文件功能前，首先需要在 XML 配置的一级标签 <beans> 中添加 context 相关的约束。

4. 配置Bean

   ```xml
   <bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource">
       <property name="url" value="${jdbc.url}"/>
       <property name="driverClassName" value="${jdbc.driver}"/>
       <property name="username" value="${jdbc.username}"/>
       <property name="password" value="${jdbc.password}"/>
   </bean>
   ```

5. 测试

   ```java
   @Test
   public void testDataSource() throws SQLException {
       ApplicationContext ac = new ClassPathXmlApplicationContext("spring-datasource.xml");
       DataSource dataSource = ac.getBean(DataSource.class);
       Connection connection = dataSource.getConnection();
       System.out.println(connection);
   }
   ```

#### 3.2.11、bean作用域

1. 概念

   > 在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表：
   >
   > | 取值              | 含义                                    | 创建对象的时机  |
   > | ----------------- | --------------------------------------- | --------------- |
   > | singleton（默认） | 在IOC容器中，这个bean的对象始终为单实例 | IOC容器初始化时 |
   > | prototype         | 这个bean在IOC容器中有多个实例           | 获取bean时      |
   >
   > 如果是在WebApplicationContext环境下还会有另外几个作用域（但不常用）：
   >
   > | 取值    | 含义                 |
   > | ------- | -------------------- |
   > | request | 在一个请求范围内有效 |
   > | session | 在一个会话范围内有效 |

2. 创建User类

   ```java
   package com.muzhi.spring6.bean;
   public class User {
   
       private Integer id;
   
       private String username;
   
       private String password;
   
       private Integer age;
   
       public User() {
       }
   
       public User(Integer id, String username, String password, Integer age) {
           this.id = id;
           this.username = username;
           this.password = password;
           this.age = age;
       }
   
       public Integer getId() {
           return id;
       }
   
       public void setId(Integer id) {
           this.id = id;
       }
   
       public String getUsername() {
           return username;
       }
   
       public void setUsername(String username) {
           this.username = username;
       }
   
       public String getPassword() {
           return password;
       }
   
       public void setPassword(String password) {
           this.password = password;
       }
   
       public Integer getAge() {
           return age;
       }
   
       public void setAge(Integer age) {
           this.age = age;
       }
   
       @Override
       public String toString() {
           return "User{" +
                   "id=" + id +
                   ", username='" + username + '\'' +
                   ", password='" + password + '\'' +
                   ", age=" + age +
                   '}';
       }
   }
   ```

3. 配置Bean

   ```xml
   <!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 -->
   <!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 -->
   <bean class="com.atguigu.spring6.bean.User" scope="prototype"></bean>
   ```

4. 测试

   ```java
   @Test
   public void testBeanScope(){
       ApplicationContext ac = new ClassPathXmlApplicationContext("spring-scope.xml");
       User user1 = ac.getBean(User.class);
       User user2 = ac.getBean(User.class);
       System.out.println(user1==user2);
   }
   ```

#### 3.2.12、bean生命周期

1. 具体的生命周期过程

   - bean对象创建（调用无参构造器）
   - 给bean对象设置属性
   - bean的后置处理器（初始化之前）
   - bean对象初始化（需在配置bean时指定初始化方法）
   - bean的后置处理器（初始化之后）
   - bean对象就绪可以使用
   - bean对象销毁（需在配置bean时指定销毁方法）
   - IOC容器关闭

2. 修改User类

   ```java
   public class User {
   
       private Integer id;
   
       private String username;
   
       private String password;
   
       private Integer age;
   
       public User() {
           System.out.println("生命周期：1、创建对象");
       }
   
       public User(Integer id, String username, String password, Integer age) {
           this.id = id;
           this.username = username;
           this.password = password;
           this.age = age;
       }
   
       public Integer getId() {
           return id;
       }
   
       public void setId(Integer id) {
           System.out.println("生命周期：2、依赖注入");
           this.id = id;
       }
   
       public String getUsername() {
           return username;
       }
   
       public void setUsername(String username) {
           this.username = username;
       }
   
       public String getPassword() {
           return password;
       }
   
       public void setPassword(String password) {
           this.password = password;
       }
   
       public Integer getAge() {
           return age;
       }
   
       public void setAge(Integer age) {
           this.age = age;
       }
   
       public void initMethod(){
           System.out.println("生命周期：3、初始化");
       }
   
       public void destroyMethod(){
           System.out.println("生命周期：5、销毁");
       }
   
       @Override
       public String toString() {
           return "User{" +
                   "id=" + id +
                   ", username='" + username + '\'' +
                   ", password='" + password + '\'' +
                   ", age=" + age +
                   '}';
       }
   }
   ```

   > 注意其中的initMethod()和destroyMethod()，可以通过配置bean指定为初始化和销毁的方法

3. 配置bean

   ```xml
   <!-- 使用init-method属性指定初始化方法 -->
   <!-- 使用destroy-method属性指定销毁方法 -->
   <bean class="com.atguigu.spring6.bean.User" scope="prototype" init-method="initMethod" destroy-method="destroyMethod">
       <property name="id" value="1001"></property>
       <property name="username" value="admin"></property>
       <property name="password" value="123456"></property>
       <property name="age" value="23"></property>
   </bean>
   ```

4. 测试

   ```java
   @Test
   public void testLife(){
       ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("spring-lifecycle.xml");
       User bean = ac.getBean(User.class);
       System.out.println("生命周期：4、通过IOC容器获取bean并使用");
       ac.close();
   }
   ```

5. bean的后置处理器

   bean的后置处理器会在生命周期的初始化前后添加额外的操作，需要实现BeanPostProcessor接口，且配置到IOC容器中，需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行

   创建bean的后置处理器：

   ```java
   package com.muzhi.spring6.process;
       
   import org.springframework.beans.BeansException;
   import org.springframework.beans.factory.config.BeanPostProcessor;
   
   public class MyBeanProcessor implements BeanPostProcessor {
       
       @Override
       public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
           System.out.println("☆☆☆" + beanName + " = " + bean);
           return bean;
       }
       
       @Override
       public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
           System.out.println("★★★" + beanName + " = " + bean);
           return bean;
       }
   }
   ```

   在IOC容器中配置后置处理器：

   ```xml
   <!-- bean的后置处理器要放入IOC容器才能生效 -->
   <bean id="myBeanProcessor" class="com.muzhi.spring6.process.MyBeanProcessor"/>
   ```

#### 3.2.13、FactoryBean

1. 简介

   > FactoryBean是Spring提供的一种整合第三方框架的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。
   >
   > ```java
   > /*
   >  * Copyright 2002-2020 the original author or authors.
   >  *
   >  * Licensed under the Apache License, Version 2.0 (the "License");
   >  * you may not use this file except in compliance with the License.
   >  * You may obtain a copy of the License at
   >  *
   >  *      https://www.apache.org/licenses/LICENSE-2.0
   >  *
   >  * Unless required by applicable law or agreed to in writing, software
   >  * distributed under the License is distributed on an "AS IS" BASIS,
   >  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   >  * See the License for the specific language governing permissions and
   >  * limitations under the License.
   >  */
   > package org.springframework.beans.factory;
   > 
   > import org.springframework.lang.Nullable;
   > 
   > /**
   >  * Interface to be implemented by objects used within a {@link BeanFactory} which
   >  * are themselves factories for individual objects. If a bean implements this
   >  * interface, it is used as a factory for an object to expose, not directly as a
   >  * bean instance that will be exposed itself.
   >  *
   >  * <p><b>NB: A bean that implements this interface cannot be used as a normal bean.</b>
   >  * A FactoryBean is defined in a bean style, but the object exposed for bean
   >  * references ({@link #getObject()}) is always the object that it creates.
   >  *
   >  * <p>FactoryBeans can support singletons and prototypes, and can either create
   >  * objects lazily on demand or eagerly on startup. The {@link SmartFactoryBean}
   >  * interface allows for exposing more fine-grained behavioral metadata.
   >  *
   >  * <p>This interface is heavily used within the framework itself, for example for
   >  * the AOP {@link org.springframework.aop.framework.ProxyFactoryBean} or the
   >  * {@link org.springframework.jndi.JndiObjectFactoryBean}. It can be used for
   >  * custom components as well; however, this is only common for infrastructure code.
   >  *
   >  * <p><b>{@code FactoryBean} is a programmatic contract. Implementations are not
   >  * supposed to rely on annotation-driven injection or other reflective facilities.</b>
   >  * {@link #getObjectType()} {@link #getObject()} invocations may arrive early in the
   >  * bootstrap process, even ahead of any post-processor setup. If you need access to
   >  * other beans, implement {@link BeanFactoryAware} and obtain them programmatically.
   >  *
   >  * <p><b>The container is only responsible for managing the lifecycle of the FactoryBean
   >  * instance, not the lifecycle of the objects created by the FactoryBean.</b> Therefore,
   >  * a destroy method on an exposed bean object (such as {@link java.io.Closeable#close()}
   >  * will <i>not</i> be called automatically. Instead, a FactoryBean should implement
   >  * {@link DisposableBean} and delegate any such close call to the underlying object.
   >  *
   >  * <p>Finally, FactoryBean objects participate in the containing BeanFactory's
   >  * synchronization of bean creation. There is usually no need for internal
   >  * synchronization other than for purposes of lazy initialization within the
   >  * FactoryBean itself (or the like).
   >  *
   >  * @author Rod Johnson
   >  * @author Juergen Hoeller
   >  * @since 08.03.2003
   >  * @param <T> the bean type
   >  * @see org.springframework.beans.factory.BeanFactory
   >  * @see org.springframework.aop.framework.ProxyFactoryBean
   >  * @see org.springframework.jndi.JndiObjectFactoryBean
   >  */
   > public interface FactoryBean<T> {
   > 
   >     /**
   >      * The name of an attribute that can be
   >      * {@link org.springframework.core.AttributeAccessor#setAttribute set} on a
   >      * {@link org.springframework.beans.factory.config.BeanDefinition} so that
   >      * factory beans can signal their object type when it can't be deduced from
   >      * the factory bean class.
   >      * @since 5.2
   >      */
   >     String OBJECT_TYPE_ATTRIBUTE = "factoryBeanObjectType";
   > 
   >     /**
   >      * Return an instance (possibly shared or independent) of the object
   >      * managed by this factory.
   >      * <p>As with a {@link BeanFactory}, this allows support for both the
   >      * Singleton and Prototype design pattern.
   >      * <p>If this FactoryBean is not fully initialized yet at the time of
   >      * the call (for example because it is involved in a circular reference),
   >      * throw a corresponding {@link FactoryBeanNotInitializedException}.
   >      * <p>As of Spring 2.0, FactoryBeans are allowed to return {@code null}
   >      * objects. The factory will consider this as normal value to be used; it
   >      * will not throw a FactoryBeanNotInitializedException in this case anymore.
   >      * FactoryBean implementations are encouraged to throw
   >      * FactoryBeanNotInitializedException themselves now, as appropriate.
   >      * @return an instance of the bean (can be {@code null})
   >      * @throws Exception in case of creation errors
   >      * @see FactoryBeanNotInitializedException
   >      */
   >     @Nullable
   >     T getObject() throws Exception;
   > 
   >     /**
   >      * Return the type of object that this FactoryBean creates,
   >      * or {@code null} if not known in advance.
   >      * <p>This allows one to check for specific types of beans without
   >      * instantiating objects, for example on autowiring.
   >      * <p>In the case of implementations that are creating a singleton object,
   >      * this method should try to avoid singleton creation as far as possible;
   >      * it should rather estimate the type in advance.
   >      * For prototypes, returning a meaningful type here is advisable too.
   >      * <p>This method can be called <i>before</i> this FactoryBean has
   >      * been fully initialized. It must not rely on state created during
   >      * initialization; of course, it can still use such state if available.
   >      * <p><b>NOTE:</b> Autowiring will simply ignore FactoryBeans that return
   >      * {@code null} here. Therefore it is highly recommended to implement
   >      * this method properly, using the current state of the FactoryBean.
   >      * @return the type of object that this FactoryBean creates,
   >      * or {@code null} if not known at the time of the call
   >      * @see ListableBeanFactory#getBeansOfType
   >      */
   >     @Nullable
   >     Class<?> getObjectType();
   > 
   >     /**
   >      * Is the object managed by this factory a singleton? That is,
   >      * will {@link #getObject()} always return the same object
   >      * (a reference that can be cached)?
   >      * <p><b>NOTE:</b> If a FactoryBean indicates to hold a singleton object,
   >      * the object returned from {@code getObject()} might get cached
   >      * by the owning BeanFactory. Hence, do not return {@code true}
   >      * unless the FactoryBean always exposes the same reference.
   >      * <p>The singleton status of the FactoryBean itself will generally
   >      * be provided by the owning BeanFactory; usually, it has to be
   >      * defined as singleton there.
   >      * <p><b>NOTE:</b> This method returning {@code false} does not
   >      * necessarily indicate that returned objects are independent instances.
   >      * An implementation of the extended {@link SmartFactoryBean} interface
   >      * may explicitly indicate independent instances through its
   >      * {@link SmartFactoryBean#isPrototype()} method. Plain {@link FactoryBean}
   >      * implementations which do not implement this extended interface are
   >      * simply assumed to always return independent instances if the
   >      * {@code isSingleton()} implementation returns {@code false}.
   >      * <p>The default implementation returns {@code true}, since a
   >      * {@code FactoryBean} typically manages a singleton instance.
   >      * @return whether the exposed object is a singleton
   >      * @see #getObject()
   >      * @see SmartFactoryBean#isPrototype()
   >      */
   >     default boolean isSingleton() {
   >         return true;
   >     }
   > }
   > ```
   >
   > 整合MyBatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。

2. 创建类 UserFactoryBean

   ```java
   package com.muzhi.spring6.bean;
   public class UserFactoryBean implements FactoryBean<User> {
       @Override
       public User getObject() throws Exception {
           return new User();
       }
   
       @Override
       public Class<?> getObjectType() {
           return User.class;
       }
   }
   ```

3. 配置Bean

   ```xml
   <bean id="user" class="com.muzhi.spring6.bean.UserFactoryBean"></bean>
   ```

4. 测试

   ```java
   @Test
   public void testUserFactoryBean(){
       //获取IOC容器
       ApplicationContext ac = new ClassPathXmlApplicationContext("spring-factorybean.xml");
       User user = (User) ac.getBean("user");
       System.out.println(user);
   }
   ```

#### 3.2.14、基于XML自动装配

> 自动装配：根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值

1. 场景模拟

   1. 创建UserController

   ```java
   package com.muzhi.spring6.autowire.controller
   public class UserController {
   
       private UserService userService;
   
       public void setUserService(UserService userService) {
           this.userService = userService;
       }
   
       public void saveUser(){
           userService.saveUser();
       }
   
   }
   ```

   2. 创建接口UserService

   ```java
   package com.muzhi.spring6.autowire.service
   public interface UserService {
   
       void saveUser();
   }
   ```

   3. 创建类UserServiceImpl实现接口UserService

   ```java
   package com.muzhi.spring6.autowire.service.impl
   public class UserServiceImpl implements UserService {
   
       private UserDao userDao;
       
       public void setUserDao(UserDao userDao) {
           this.userDao = userDao;
       }
       @Override
       public void saveUser() {
           userDao.saveUser();
       }
   }
   ```

   4. 创建接口UserDao

   ```java
   package com.muzhi.spring6.autowire.dao
   public interface UserDao {
   
       void saveUser();
   }
   ```

   5. 创建类UserDaoImpl实现接口UserDao

   ```java
   package com.muzhi.spring6.autowire.dao.impl
   public class UserDaoImpl implements UserDao {
   
       @Override
       public void saveUser() {
           System.out.println("保存成功");
       }
   }
   ```

2. 配置Bean

   > 使用bean标签的autowire属性设置自动装配效果
   >
   > 自动装配方式：byType
   >
   > byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值
   >
   > 若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null
   >
   > 若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常NoUniqueBeanDefinitionException

   ```xml
   <bean id="userController" class="com.muzhi.spring6.autowire.controller.UserController" autowire="byType"></bean>
   <bean id="userService" class="com.muzhi.spring6.autowire.service.impl.UserServiceImpl" autowire="byType"></bean>
   <bean id="userDao" class="com.muzhi.spring6.autowire.dao.impl.UserDaoImpl"></bean>
   ```

   > 自动装配方式：byName
   >
   > byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值

   ```xml
   <bean id="userController" class="com.muzhi.spring6.autowire.controller.UserController" autowire="byName"></bean>
   
   <bean id="userService" class="com.muzhi.spring6.autowire.service.impl.UserServiceImpl" autowire="byName"></bean>
   <bean id="userServiceImpl" class="com.muzhi.spring6.autowire.service.impl.UserServiceImpl" autowire="byName"></bean>
   
   <bean id="userDao" class="com.muzhi.spring6.autowire.dao.impl.UserDaoImpl"></bean>
   <bean id="userDaoImpl" class="com.muzhi.spring6.autowire.dao.impl.UserDaoImpl"></bean>
   ```

3. 测试

   ```java
   @Test
   public void testAutoWireByXML(){
       ApplicationContext ac = new ClassPathXmlApplicationContext("autowire-xml.xml");
       UserController userController = ac.getBean(UserController.class);
       userController.saveUser();
   }
   ```

### 3.3、基于注解管理Bean ☆

从 Java 5 开始，Java 增加了对注解（Annotation）的支持，它是代码中的一种特殊标记，可以在编译、类加载和运行时被读取，执行相应的处理。开发人员可以通过注解在不改变原有代码和逻辑的情况下，在源代码中嵌入补充信息。

Spring 从 2.5 版本开始提供了对注解技术的全面支持，我们可以使用注解来实现自动装配，简化 Spring 的 XML 配置。

Spring 通过注解实现自动装配的步骤如下：

1. 引入依赖
2. 开启组件扫描
3. 使用注解定义 Bean
4. 依赖注入

#### 3.3.1、搭建子模块spring6-ioc-annotation

1. 搭建模块

   > 搭建方式如：spring6-ioc-xml

2. 引入配置文件

   > 引入log4j2.xml

3. 添加依赖

   ```xml
   <dependencies>
       <!--spring context依赖-->
       <!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了-->
       <dependency>
           <groupId>org.springframework</groupId>
           <artifactId>spring-context</artifactId>
           <version>6.0.3</version>
       </dependency>
   
       <!--junit5测试-->
       <dependency>
           <groupId>org.junit.jupiter</groupId>
           <artifactId>junit-jupiter-api</artifactId>
       </dependency>
   
       <!--log4j2的依赖-->
       <dependency>
           <groupId>org.apache.logging.log4j</groupId>
           <artifactId>log4j-core</artifactId>
           <version>2.19.0</version>
       </dependency>
       <dependency>
           <groupId>org.apache.logging.log4j</groupId>
           <artifactId>log4j-slf4j2-impl</artifactId>
           <version>2.19.0</version>
       </dependency>
   </dependencies>
   ```

   > 注意：在使用 <context:component-scan> 元素开启自动扫描功能前，首先需要在 XML 配置的一级标签 <beans> 中添加 context 相关的约束。

#### 3.3.2、开启组件扫描

##### 3.3.2.1、最基本的扫描方式

```xml
<context:component-scan base-package="com.muzhi.spring6">
</context:component-scan>
```

##### 3.3.2.2、指定排除的组件

```xml
<context:component-scan base-package="com.muzhi.spring6">
    <!-- context:exclude-filter标签：指定排除规则 -->
    <!-- 
 		type：设置排除或包含的依据
		type="annotation"，根据注解排除，expression中设置要排除的注解的全类名
		type="assignable"，根据类型排除，expression中设置要排除的类型的全类名
	-->
    <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
        <!--<context:exclude-filter type="assignable" expression="com.atguigu.spring6.controller.UserController"/>-->
</context:component-scan>
```

##### 3.3.2.3、仅扫描指定组件

```xml
<context:component-scan base-package="com.muzhi" use-default-filters="false">
    <!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 -->
    <!-- use-default-filters属性：取值false表示关闭默认扫描规则 -->
    <!-- 此时必须设置use-default-filters="false"，因为默认规则即扫描指定包下所有类 -->
    <!-- 
 		type：设置排除或包含的依据
		type="annotation"，根据注解排除，expression中设置要排除的注解的全类名
		type="assignable"，根据类型排除，expression中设置要排除的类型的全类名
	-->
    <context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
	<!--<context:include-filter type="assignable" expression="com.atguigu.spring6.controller.UserController"/>-->
</context:component-scan>
```

#### 3.3.3、使用注解定义Bean

> Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。
>
> | 注解        | 说明                                                         |
> | ----------- | ------------------------------------------------------------ |
> | @Component  | 该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。  使用时只需将该注解标注在相应类上即可。 |
> | @Repository | 该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 |
> | @Service    | 该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 |
> | @Controller | 该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 |

#### 3.3.4、@Autowired注入

> 单独使用@Autowired注解，**默认根据类型装配**。【默认是byType】
>
> 查看源码：
>
> ```java
> package org.springframework.beans.factory.annotation;
> 
> import java.lang.annotation.Documented;
> import java.lang.annotation.ElementType;
> import java.lang.annotation.Retention;
> import java.lang.annotation.RetentionPolicy;
> import java.lang.annotation.Target;
> 
> @Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
> @Retention(RetentionPolicy.RUNTIME)
> @Documented
> public @interface Autowired {
>     boolean required() default true;
> }
> ```
>
> 源码中有两处需要注意：
>
> - 第一处：该注解可以标注在哪里？
>   - 构造方法上
>   - 方法上
>   - 形参上
>   - 属性上
>   - 注解上
> - 第二处：该注解有一个required属性，默认值是true，表示在注入的时候要求被注入的Bean必须是存在的，如果不存在则报错。如果required属性设置为false，表示注入的Bean存在或者不存在都没关系，存在的话就注入，不存在的话，也不报错。

##### 3.3.4.1、属性注入

1. 创建UserDao接口

   ```java
   package com.muzhi.spring6.dao;
   
   public interface UserDao {
   
       public void print();
   }
   ```

2. 创建UserDaoImpl实现

   ```java
   package com.muzhi.spring6.dao.impl;
   
   import com.atguigu.spring6.dao.UserDao;
   import org.springframework.stereotype.Repository;
   
   @Repository
   public class UserDaoImpl implements UserDao {
   
       @Override
       public void print() {
           System.out.println("Dao层执行结束");
       }
   }
   ```

3. 创建UserService接口

   ```java
   package com.atguigu.spring6.service;
   
   public interface UserService {
   
       public void out();
   }
   ```

4. 创建UserServiceImpl实现类

   ```java
   package com.atguigu.spring6.service.impl;
   
   import com.atguigu.spring6.dao.UserDao;
   import com.atguigu.spring6.service.UserService;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.stereotype.Service;
   
   @Service
   public class UserServiceImpl implements UserService {
   
       @Autowired
       private UserDao userDao;
   
       @Override
       public void out() {
           userDao.print();
           System.out.println("Service层执行结束");
       }
   }
   ```

5. 创建UserController

   ```java
   package com.muzhi.spring6.controller;
   
   import com.atguigu.spring6.service.UserService;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.stereotype.Controller;
   
   @Controller
   public class UserController {
   
       @Autowired
       private UserService userService;
   
       public void out() {
           userService.out();
           System.out.println("Controller层执行结束。");
       }
   
   }
   ```

6. 测试

   ```java
   package com.muzhi.spring6.bean;
   
   import com.muzhi.spring6.controller.UserController;
   import org.junit.jupiter.api.Test;
   import org.slf4j.Logger;
   import org.slf4j.LoggerFactory;
   import org.springframework.context.ApplicationContext;
   import org.springframework.context.support.ClassPathXmlApplicationContext;
   
   public class UserTest {
   
       private Logger logger = LoggerFactory.getLogger(UserTest.class);
   
       @Test
       public void testAnnotation(){
           ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
           UserController userController = context.getBean("userController", UserController.class);
           userController.out();
           logger.info("执行成功");
       }
   }
   ```

7. 测试结果：

   ![image-20240502233130676](https://raw.githubusercontent.com/MuzhiCoder/MuZhiCoderImages/main/public-images/image-20240502233130676.png)

   以上构造方法和setter方法都没有提供，经过测试，仍然可以注入成功。

##### 3.3.4.2、set注入

1. 修改UserServiceImpl类

   ```java
   package com.muzhi.spring6.service.impl;
   
   import com.muzhi.spring6.dao.UserDao;
   import com.muzhi.spring6.service.UserService;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.stereotype.Service;
   
   @Service
   public class UserServiceImpl implements UserService {
   
       private UserDao userDao;
   
       @Autowired
       public void setUserDao(UserDao userDao) {
           this.userDao = userDao;
       }
   
       @Override
       public void out() {
           userDao.print();
           System.out.println("Service层执行结束");
       }
   }
   ```

2. 修改UserController类

   ```java
   package com.muzhi.spring6.controller;
   
   import com.muzhi.spring6.service.UserService;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.stereotype.Controller;
   
   @Controller
   public class UserController {
   
       private UserService userService;
   
       @Autowired
       public void setUserService(UserService userService) {
           this.userService = userService;
       }
   
       public void out() {
           userService.out();
           System.out.println("Controller层执行结束。");
       }
   }
   ```

##### 3.3.4.3、构造方法注入

1. 修改UserServiceImpl类

   ```java
   package com.muzhi.spring6.service.impl;
   
   import com.muzhi.spring6.dao.UserDao;
   import com.muzhi.spring6.service.UserService;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.stereotype.Service;
   
   @Service
   public class UserServiceImpl implements UserService {
   
       private UserDao userDao;
   
       @Autowired
       public UserServiceImpl(UserDao userDao) {
           this.userDao = userDao;
       }
   
       @Override
       public void out() {
           userDao.print();
           System.out.println("Service层执行结束");
       }
   }
   ```

2. 修改UserController类

   ```java
   package com.muzhi.spring6.controller;
   
   import com.muzhi.spring6.service.UserService;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.stereotype.Controller;
   
   @Controller
   public class UserController {
   
       private UserService userService;
   
       @Autowired
       public UserController(UserService userService) {
           this.userService = userService;
       }
   
       public void out() {
           userService.out();
           System.out.println("Controller层执行结束。");
       }
   
   }
   ```

##### 3.3.4.4、形参注入

1. 修改UserServiceImpl类

   ```java
   package com.muzhi.spring6.service.impl;
   
   import com.muzhi.spring6.dao.UserDao;
   import com.muzhi.spring6.service.UserService;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.stereotype.Service;
   
   @Service
   public class UserServiceImpl implements UserService {
   
       private UserDao userDao;
   
       public UserServiceImpl(@Autowired UserDao userDao) {
           this.userDao = userDao;
       }
   
       @Override
       public void out() {
           userDao.print();
           System.out.println("Service层执行结束");
       }
   }
   ```

2. 修改UserController类

   ```java
   package com.muzhi.spring6.controller;
   
   import com.muzhi.spring6.service.UserService;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.stereotype.Controller;
   
   @Controller
   public class UserController {
   
       private UserService userService;
   
       public UserController(@Autowired UserService userService) {
           this.userService = userService;
       }
   
       public void out() {
           userService.out();
           System.out.println("Controller层执行结束。");
       }
   
   }
   ```

##### 3.3.4.5、只有一个构造函数，无注解

1. 修改UserServiceImpl类

   ```java
   package com.muzhi.spring6.service.impl;
   
   import com.muzhi.spring6.dao.UserDao;
   import com.muzhi.spring6.service.UserService;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.beans.factory.annotation.Qualifier;
   import org.springframework.stereotype.Service;
   
   @Service
   public class UserServiceImpl implements UserService {
   
       @Autowired
       private UserDao userDao;
   
       public UserServiceImpl(UserDao userDao) {
           this.userDao = userDao;
       }
   
       @Override
       public void out() {
           userDao.print();
           System.out.println("Service层执行结束");
       }
   }
   ```

   **当有参数的构造方法只有一个时，@Autowired注解可以省略。**

   说明：有多个构造方法时呢？大家可以测试（再添加一个无参构造函数），测试报错

##### 3.3.4.6、@Autowired注解和@Qualifier注解联合

1. 添加dao层实现

   ```java
   package com.muzhi.spring6.dao.impl;
   
   import com.muzhi.spring6.dao.UserDao;
   import org.springframework.stereotype.Repository;
   
   @Repository
   public class UserDaoRedisImpl implements UserDao {
   
       @Override
       public void print() {
           System.out.println("Redis Dao层执行结束");
       }
   }
   ```

2. 测试：测试异常

   > ```
   > Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'myUserService' defined in file [\spring6\spring6-ioc-annotation\target\classes\com\muzhi\spring6\resource\service\UserServiceImpl.class]: Unsatisfied dependency expressed through constructor parameter 0: No qualifying bean of type 'com.muzhi.spring6.resource.dao.UserDao' available: expected single matching bean but found 2: myUserDao,myUserRedisDao
   > ```
   >
   > 错误信息中说：不能装配，UserDao这个Bean的数量等于2
   >
   > 怎么解决这个问题呢？**当然要byName，根据名称进行装配了。**

3. 修改UserServiceImpl类

   ```java
   package com.muzhi.spring6.service.impl;
   
   import com.muzhi.spring6.dao.UserDao;
   import com.muzhi.spring6.service.UserService;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.stereotype.Service;
   
   @Service
   public class UserServiceImpl implements UserService {
   
       @Autowired
       @Qualifier("userDaoImpl") // 指定bean的名字
       private UserDao userDao;
   
       @Override
       public void out() {
           userDao.print();
           System.out.println("Service层执行结束");
       }
   }
   ```

4. 总结

   > - @Autowired注解可以出现在：属性上、构造方法上、构造方法的参数上、setter方法上。
   > - 当带参数的构造方法只有一个，@Autowired注解可以省略。（）
   > - @Autowired注解默认根据类型注入。如果要根据名称注入的话，需要配合@Qualifier注解一起使用。

#### 3.3.5、@Resource注入

@Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？

- @Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。)
- @Autowired注解是Spring框架自己的。
- **@Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。**
- **@Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起用。**
- @Resource注解用在属性上、setter方法上。
- @Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。

@Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：

​	**如果是JDK8的话不需要额外引入依赖。高于JDK11或低于JDK8需要引入以下依赖。**

```xml
<dependency>
    <groupId>jakarta.annotation</groupId>
    <artifactId>jakarta.annotation-api</artifactId>
    <version>2.1.1</version>
</dependency>
```

源码：

> ```java
> package jakarta.annotation;
> 
> import java.lang.annotation.ElementType;
> import java.lang.annotation.Repeatable;
> import java.lang.annotation.Retention;
> import java.lang.annotation.RetentionPolicy;
> import java.lang.annotation.Target;
> 
> @Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
> @Retention(RetentionPolicy.RUNTIME)
> @Repeatable(Resources.class)
> public @interface Resource {
>     String name() default "";
> 
>     String lookup() default "";
> 
>     Class<?> type() default Object.class;
> 
>     Resource.AuthenticationType authenticationType() default Resource.AuthenticationType.CONTAINER;
> 
>     boolean shareable() default true;
> 
>     String mappedName() default "";
> 
>     String description() default "";
> 
>     public static enum AuthenticationType {
>         CONTAINER,
>         APPLICATION;
> 
>         private AuthenticationType() {
>         }
>     }
> }
> ```

##### 3.3.5.1、根据name注入

1. 修改UserDaoImpl类

   ```java
   package com.muzhi.spring6.dao.impl;
   
   import com.muzhi.spring6.dao.UserDao;
   import org.springframework.stereotype.Repository;
   
   @Repository("myUserDao")
   public class UserDaoImpl implements UserDao {
   
       @Override
       public void print() {
           System.out.println("Dao层执行结束");
       }
   }
   ```

2. 修改UserServiceImpl类

   ```java
   package com.atguigu.spring6.service.impl;
   
   import com.atguigu.spring6.dao.UserDao;
   import com.atguigu.spring6.service.UserService;
   import jakarta.annotation.Resource;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.beans.factory.annotation.Qualifier;
   import org.springframework.stereotype.Service;
   
   @Service
   public class UserServiceImpl implements UserService {
   
       @Resource(name = "myUserDao")
       private UserDao myUserDao;
   
       @Override
       public void out() {
           myUserDao.print();
           System.out.println("Service层执行结束");
       }
   }
   ```

##### 3.3.5.2、name未知注入

1. 修改UserDaoImpl类

   ```java
   package com.muzhi.spring6.dao.impl;
   
   import com.muzhi.spring6.dao.UserDao;
   import org.springframework.stereotype.Repository;
   
   @Repository("myUserDao")
   public class UserDaoImpl implements UserDao {
   
       @Override
       public void print() {
           System.out.println("Dao层执行结束");
       }
   }
   ```

2. 修改UserServiceImpl类

   ```java
   package com.muzhi.spring6.service.impl;
   
   import com.muzhi.spring6.dao.UserDao;
   import com.muzhi.spring6.service.UserService;
   import jakarta.annotation.Resource;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.beans.factory.annotation.Qualifier;
   import org.springframework.stereotype.Service;
   
   @Service
   public class UserServiceImpl implements UserService {
   
       @Resource
       private UserDao myUserDao;
   
       @Override
       public void out() {
           myUserDao.print();
           System.out.println("Service层执行结束");
       }
   }
   ```

   当@Resource注解使用时没有指定name的时候，还是根据name进行查找，这个name是属性名。

##### 3.3.5.3、其他情况

1. 修改UserServiceImpl类，userDao1属性名不存在。

   ```java
   package com.muzhi.spring6.service.impl;
   
   import com.muzhi.spring6.dao.UserDao;
   import com.muzhi.spring6.service.UserService;
   import jakarta.annotation.Resource;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.beans.factory.annotation.Qualifier;
   import org.springframework.stereotype.Service;
   
   @Service
   public class UserServiceImpl implements UserService {
   
       @Resource
       private UserDao userDao1;
   
       @Override
       public void out() {
           userDao1.print();
           System.out.println("Service层执行结束");
       }
   }
   ```

2. 测试异常

   根据异常信息得知：显然当通过name找不到的时候，自然会启动byType进行注入，以上的错误是因为UserDao接口下有两个实现类导致的。所以根据类型注入就会报错。

   @Resource的set注入可以自行测试

3. **总结：**

   @Resource注解：默认byName注入，没有指定name时把属性名当做name，根据name找不到时，才会byType注入。byType注入时，某种类型的Bean只能有一个。

#### 3.3.6、Spring全注解开发

1. 全注解开发就是不再使用spring配置文件了，写一个配置类来代替配置文件。

   ```java
   package com.muzhi.spring6.config;
   
   import org.springframework.context.annotation.ComponentScan;
   import org.springframework.context.annotation.Configuration;
   
   @Configuration
   //@ComponentScan({"com.muzhi.spring6.controller", "com.muzhi.spring6.service","com.muzhi.spring6.dao"})
   @ComponentScan("com.atguigu.spring6")
   public class Spring6Config {
   }
   ```

2. 测试

   ```java
   @Test
   public void testAllAnnotation(){
       ApplicationContext context = new AnnotationConfigApplicationContext(Spring6Config.class);
       UserController userController = context.getBean("userController", UserController.class);
       userController.out();
       logger.info("执行成功");
   }
   ```

   

